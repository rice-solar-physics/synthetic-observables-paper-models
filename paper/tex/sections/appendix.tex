%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   Appendix 1: NEI                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Non-equilibrium Ion Populations}\label{nei}

In order to account for ionization non-equilibrium, we compute $f_{X,k}$ by solving the time-dependent level population equations for each ion in each element,
\begin{equation}\label{eq:nei}
    \frac{\partial f_k}{\partial t} = n_e(R_{k+1}f_{k+1} + I_{k-1}f_{k-1} - I_kf_k - R_kf_k)
\end{equation}
where $R_k$ and $I_k$ are the temperature-dependent recombination and ionization rates, respectively, of level $k$. Note that for an element with atomic number $Z$, we must solve $Z+1$ coupled differential equations to find the non-equilibrium level populations. Setting the left hand side of \autoref{eq:nei} gives the equation of ionization equilibrium. Casting \autoref{eq:nei} in matrix form,
\begin{equation}\label{eq:nei_mat}
    \dot{\mathbf{F}} = \mathbf{A}\mathbf{F},
\end{equation}
where $\mathbf{F}=(f_1,f_2,\ldots,f_k,\ldots,f_{Z+1})$ and $\mathbf{A}$ is a ${Z+1\times Z+1}$ tridiagonal matrix containing the ionization and recombination rates, multiplied by the electron density,

\begin{equation}
    \mathbf{A} = n_e
        \begin{pmatrix}
            -(I_0 + R_0) & R_1 & 0 & \dots & 0 \\
            I_0 & -(I_1 + R_1) & R_2 & \dots & 0 \\
            \vdots & \ddots & \ddots & & \vdots \\
            \vdots & I_{i-1} & -(I_i + R_i) & R_{i+1} & \vdots \\
            \vdots & & \ddots & \ddots & \vdots \\
            0 & \dots & I_{Z-2} & -(I_{Z-1} + R_{Z-1}) & R_Z \\
            0 & \dots & 0 & I_{Z-1} & -(I_Z + R_Z) 
        \end{pmatrix}.
\end{equation}

Due to drastic changes in the ionization and recombination rates with temperature, the above system of equations is very ``stiff'', making explicit schemes extremely sensitive to the choice of timestep \citep{macneice_numerical_1984,bradshaw_numerical_2009}. To solve \autoref{eq:nei_mat}, we use the ``deferred correction'' method of \citet{npl_modern_1961}, as pointed out by \citet{macneice_numerical_1984},
\begin{equation}
    \mathbf{F}_{j+1} = \mathbf{F}_j + \frac{\Delta t}{2}(\dot{\mathbf{F}}_{j+1} + \dot{\mathbf{F}}_j) + \mathrm{h.o.t.}
\end{equation}
where the $j$ index represents time. Rearranging the above expression and using \autoref{eq:nei_mat}, we can find an expression for $\mathbf{F}_{j+1}$,
\begin{equation}
    \mathbf{F}_{j+1} \approx \left(\mathbb{I} - \frac{\Delta t}{2}\mathbf{A}_{j+1}\right)^{-1}\left(\mathbb{I} + \frac{\Delta t}{2}\mathbf{A}_{j}\right)\mathbf{F}_j
\end{equation}
where $\mathbb{I}$ is the identity matrix. To solve \autoref{eq:nei_mat}, we need only compute $\mathbf{A}_j$ for each $T(t_j)$ and set $\mathbf{F}_0$ to the equilibrium ion populations. We solve \autoref{eq:nei_mat} for all elements in \autoref{tab:elements} and for each loop in the \AR{}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   Appendix 2: Timelags                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing Timelags}\label{timelag_details}

To find the associated timelag for a channel pair in a given pixel, we compute the cross-correlation between the timeseries associated with each channel and find the delay which maximizes this cross-correlation. We can express the cross-correlation $\mathcal{C}$ between two channels $A$ and $B$ as,
\begin{equation}\label{eq:cc_pre}
    \mathcal{C}_{AB}(\tau) = \mathcal{I}_A(t)\star\mathcal{I}_B(t) = \mathcal{I}_A(-t)\ast\mathcal{I}_B(t)
\end{equation}
where $\star$ and $\ast$ represent the correlation and convolution operators, respectively, $\tau$ is the lag and
\begin{equation*}
    \mathcal{I}_c(t)=\frac{I_c(t)-\bar{I}_c}{\sigma_{c}},
\end{equation*}
is the mean-subtracted and scaled intensity of channel $c$ as a function of time. Taking the fourier transform of both sides of \autoref{eq:cc_pre} and using the convolution theorem,
\begin{align*}
    \mathcal{F}\{\mathcal{C}_{AB}(\tau)\} &= \mathcal{F}\{\mathcal{I}_A(-t)\ast\mathcal{I}_B(t)\},\\
    &= \mathcal{F}\{\mathcal{I}_A(-t)\}\mathcal{F}\{\mathcal{I}_B(t)\}.
\end{align*}
Taking the inverse Fourier transform, $\mathcal{F}^{-1}$, of both sides of the above expression gives,
\begin{align}\label{eq:cc}
    \mathcal{C}_{AB}(\tau) &= \mathcal{F}^{-1}\{\mathcal{F}\{\mathcal{I}_A(-t)\}\mathcal{F}\{\mathcal{I}_B(t)\}\}.
\end{align}
Scaling \autoref{eq:cc} by the length of the intensity timeseries $I(t)$ yields the same result as that of the correlation defined in section 2 of \citet{viall_evidence_2012}. Furthermore, the \textit{timelag} between channels $A$ and $B$ is defined as,
\begin{equation}\label{eq:timelag}
    \tau_{AB} = \argmax_{\tau}\,\mathcal{C}_{AB}(\tau).
\end{equation}

By exploiting the definition of the cross-correlation as given in \autoref{eq:cc}, we can leverage existing Fourier transform algorithms in order to compute the $\mathcal{C}_{AB}$ in a scalable and efficient manner. For a 500-by-500 pixel active region observation and 15 possible channel pairs, we need to compute $\tau_{AB}$ nearly $4\times10^6$ times. We use the highly-optimized and thoroughly tested Fourier transform algorithms in the NumPy Python library for array computations \citep{oliphant_guide_2006} combined with the Dask library for parallel and distributed computing \citep{dask_development_team_dask_2016}. Using Dask, we are able to parallelize this operation over many cores such that, on a 64-core machine, we are able to compute timelags for all 15 channel pairs in every pixel of the \AR{} in approximately twenty minutes.