%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   Methods                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modeling}\label{modeling}

\begin{pycode}[manager_methods]
manager_methods = texfigure.Manager(pytex, './', python_dir='python', fig_dir='figures', data_dir='data')
\end{pycode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Field Extrapolation %%%%%%%%%%%%%%%%%%%%
\subsection{Magnetic Field Extrapolation}\label{field}

We choose \AR{} NOAA 1158, as observed by the HMI instrument \citet{hoeksema_helioseismic_2014} on 12 February 2011, from the list of active regions studied by \citet{warren_systematic_2012}. We model the geometry of \AR{} NOAA 1158 by computing the three-dimensional magnetic field using the oblique potential field extrapolation method of \citet{schmidt_observable_1964} as outlined in \citet[section 3]{sakurai_greens_1982}. The extrapolation technique of \citeauthor{schmidt_observable_1964} is well-suited for our purposes due to its simplicity and efficiency though we note it is only applicable on the scale of an \AR{}. We include the oblique correction to account for the fact that the \AR{} is off of disk center.

\begin{pycode}[manager_methods]
# Load AR
ar = synthesizAR.Field.restore(os.path.join(manager_methods.data_dir, 'base_noaa1158'), lazy=True)
# Import maps
aia_map = Map(manager_methods.data_file('aia_171_cutout.fits'))
hmi_map = Map(manager_methods.data_file('hmi_magnetogram.fits'))
# Prep HMI map
hmi_map = hmi_map.rotate(order=3).submap(
    aia_map.bottom_left_coord, aia_map.top_right_coord)
# Plot
fig = plt.figure()
line_frequency = 20
plt.subplots_adjust(wspace=0.03)
####################################################
#                       HMI                        #
####################################################
ax = fig.add_subplot(1,2,1,projection=hmi_map,)
hmi_map.plot(
    title=False,annotate=False,
    norm=matplotlib.colors.SymLogNorm(100,vmin=-1e3,vmax=1e3),
    cmap='RdBu_r')
for l in ar.loops[::line_frequency]:
    c = l.coordinates.transform_to(
            'heliographic_stonyhurst').transform_to(hmi_map.coordinate_frame)
    ax.plot_coord(c, '-', color='k', lw=1, alpha=0.35)
ax.grid(alpha=0)
# HPC Axes
lon,lat = ax.coords[0],ax.coords[1]
lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'])
lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
lon.set_axislabel(r'Helioprojective Longitude [arcsec]', fontsize=plt.rcParams['axes.labelsize'])
lat.set_axislabel(r'Helioprojective Latitude [arcsec]', fontsize=plt.rcParams['axes.labelsize'])
# HGS Axes
hgs_lon,hgs_lat = hmi_map.draw_grid(axes=ax,grid_spacing=10*u.deg,alpha=0.75,color='k')
hgs_lat.set_ticklabel_visible(False)
hgs_lon.set_ticklabel_visible(False)
hgs_lon.set_axislabel('')
hgs_lat.set_axislabel('')
hgs_lat.set_ticks_visible(False)
hgs_lon.set_ticks_visible(False)
hgs_lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
hgs_lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'])
# Label
xtext,ytext = hmi_map.world_to_pixel(
    SkyCoord(Tx=-425*u.arcsec,Ty=-95*u.arcsec,frame=hmi_map.coordinate_frame))
ax.text(xtext.value, ytext.value, 'HMI LOS Magnetogram', color='k')
####################################################
#                       AIA                        #
####################################################
ax = fig.add_subplot(1,2,2,projection=aia_map,)
aia_map.plot(
    title=False,annotate=False,
    norm=ImageNormalize(vmin=0,vmax=5e3,stretch=AsinhStretch(0.1)))
for l in ar.loops[::line_frequency]:
    c = l.coordinates.transform_to(
            'heliographic_stonyhurst').transform_to(aia_map.coordinate_frame)
    ax.plot_coord(c, '-', color='w', lw=1, alpha=0.35)
ax.grid(alpha=0)
# HPC Axes
lon,lat = ax.coords[0],ax.coords[1]
lon.set_ticks(color='w')
lat.set_ticks(color='w')
lat.set_ticklabel_visible(False)
# HGS Axes
hgs_lon,hgs_lat = aia_map.draw_grid(axes=ax,grid_spacing=10*u.deg,alpha=0.75,color='w')
hgs_lat.set_axislabel('Heliographic Latitude [arcsec]',
                      fontsize=plt.rcParams['axes.labelsize'])
hgs_lon.set_axislabel('Heliographic Longitude [arcsec]',
                      fontsize=plt.rcParams['axes.labelsize'])
hgs_lat.set_ticklabel_visible(True)
hgs_lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'])
hgs_lon.set_ticklabel_visible(True)
hgs_lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
hgs_lat.set_ticks_visible(False)
hgs_lon.set_ticks_visible(False)
# Label
xtext,ytext = aia_map.world_to_pixel(
    SkyCoord(Tx=-425*u.arcsec,Ty=-95*u.arcsec,frame=aia_map.coordinate_frame))
ax.text(xtext.value, ytext.value, r'AIA 171 $\mathrm{\mathring{A}}$', color='w')
####################################################
#                  Save figure                     #
####################################################
fig_aia_hmi_lines = manager_methods.save_figure('magnetogram',)
fig_aia_hmi_lines.caption = r'HMI (left) and AIA 171 \AA{} (right) observations of \AR{} NOAA 1158 on 12 February 2011 15:33 UTC, with 250 out of the total 5000 fieldlines overlaid.'
\end{pycode}
\py[manager_methods]|fig_aia_hmi_lines|

After computing the three-dimensional vector field from the observed magnetogram, we trace $5\times10^3$ fieldlines through the extrapolated volume using the streamline tracing functionality in the yt software package \citep{turk_yt_2011}. We choose only closed fieldlines in the range $20<L<300$ Mm, where $L$ is the full length of the loop. \autoref{fig:magnetogram} shows a subset of the traced loops overlaid on the observed HMI magnetogram and a concurrent AIA 171 \AA{} image of NOAA 1158. A qualitative comparison between the extrapolated fieldlines and the loops visible in the AIA 171 \AA{} image reveals that our field extrapolation and line tracing does a reasonable job of capturing the three-dimensional geometry of the \AR{}. \autoref{fig:loops} shows the distribution of full lengths for the traced loops.

\begin{pycode}[manager_methods]
from formatting import hist_step
fig = plt.figure()
ax = fig.gca()
vals,bins = np.histogram([l.full_length.to(u.Mm).value for l in ar.loops], bins='scott',)
hist_step(ax, vals, bins, color='k',lw=2)
ax.set_xlabel(r'$L$ [Mm]');
ax.set_ylabel(r'Number of Loops');
ax.set_ylim(-100,1300)
ax.set_xlim(-1,260)
# Spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_bounds(ax.get_yticks()[1], ax.get_yticks()[-2])
ax.spines['bottom'].set_bounds(ax.get_xticks()[1], ax.get_xticks()[-2])
fig_loop_dist = manager_methods.save_figure('loops',)
fig_loop_dist.caption = r'Distribution of loop lengths (in Mm) traced from field extrapolation of magnetogram of NOAA 1158. A total of 5000 fieldlines were traced through the extrapolated volume.'
\end{pycode}
\py[manager_methods]|fig_loop_dist|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Loop Hydrodynamics %%%%%%%%%%%%%%%%%%%%%%
\subsection{Loop Hydrodynamics}\label{loops}

The low-$\beta$ nature of the coronal plasma allows us to model the solar atmosphere as an ensemble of independently-heated loops using a field-aligned hydrodynamic model. To model the dynamics of each individual loop, we use the enthalpy-based thermal evolution of loops (EBTEL) model \citep{klimchuk_highly_2008,cargill_enthalpy-based_2012}. Specifically, we use the two-fluid version of the EBTEL model as described in \citep{barnes_inference_2016}. EBTEL solves the time-dependent, spatially-integrated hydrodynamic equations and has been successfully benchmarked against field-aligned hydrodynamic codes. Though EBTEL only computes spatially-averaged quantities in the coronal portion of the loop, its efficiency allows us to calculate time-dependent solutions for many thousands of loops in a few minutes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Heating %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Heating Model}\label{heating}

We parameterize the heating input in terms of discrete heating pulses on a single strand with triangular profiles of total duration $\tau=200$ s. For each event $i$, there are two parameters: the maximum heating rate $Q_i$ and the waiting time prior to the event $t_{wait,i}$. We choose $Q_i$ from a power-law distribution with slope $-2.5$ and we define the waiting time such that $t_{wait,i}$ is the amount of time between when event $i-1$ ends and event $i$ begins. Using the model of \citet{cargill_active_2014}, we relate the waiting time and the event energy such that $t_{wait,i}\propto Q_i$. The physical motivation for this scaling is as follows. In the nanoflare model of \citet{parker_nanoflares_1988}, random convective motions continually stress loops rooted in the photosphere, leading to the buildup and and eventual release of energy. If the field is stressed for a long amount of time without relaxation, large discontinuities will have time to develop in the field, leading to a dramatic release of energy. Conversely, if the field relaxes quickly, there is not enough time for the field to become sufficiently stressed and the resulting energy release will be relatively small. 

In this work we explore three different heating scenarios: low-, intermediate-, and high-frequency nanoflares. We define the \textit{heating frequency} in terms of the ratio between the loop cooling time, $\tau_{cool}$, and the average waiting time of all events on a given strand, $\langle t_{wait}\rangle$,

\begin{equation}\label{eq:heating_types}
    \varepsilon = \frac{\langle t_{wait}\rangle}{\tau_{cool}}
    \begin{cases} 
        < 1 &  \text{high frequency},\\
        \sim1 & \text{intermediate frequency}, \\
        > 1 & \text{low frequency}.
     \end{cases}
\end{equation}

We choose to parameterize the heating in terms of the cooling time rather than an absolute value of $\langle t_{wait}\rangle$ as $\tau_{cool}\sim L$ \citep[see appendix]{cargill_active_2014}. While a waiting time of 2000 s might correspond to low frequency heating for a 20 Mm loop, it would correspond to high frequency heating in the case of a 150 Mm loop. By parameterizing the heating in this way, we ensure that all loops in the \AR{} are heated at the same frequency relative to their cooling time. \autoref{fig:hydro-profiles} shows the heating rate, electron temperature, and density as a function of time, for a single loop, for all three of the heating scenarios list above. 

\begin{pycode}[manager_methods]
import h5py
from formatting import heating_palette
fig,axes = plt.subplots(3, 1, sharex=True)
plt.subplots_adjust(hspace=0.)
colors = heating_palette()
i_loop=680
heating = ['high_frequency', 'intermediate_frequency','low_frequency']
loop = ar.loops[i_loop]
for i,h in enumerate(heating):
    loop.parameters_savefile = os.path.join(manager_methods.data_dir, f'{h}', 'loop_parameters.h5')
    with h5py.File(loop.parameters_savefile, 'r') as hf:
        q = np.array(hf[f'loop{i_loop:06d}']['heating_rate'])
    axes[0].plot(loop.time, q, color=colors[i], label=h.split('_')[0].capitalize(),)
    axes[1].plot(loop.time, loop.electron_temperature[:,0].to(u.MK), color=colors[i],)
    axes[2].plot(loop.time, loop.density[:,0]/1e9, color=colors[i],)
# Legend
axes[0].legend(ncol=3,loc="lower left", bbox_to_anchor=(0.,1.02),frameon=False,)
# Labels and limits
axes[0].set_xlim(0,3e4)
#axes[0].set_ylim(-1e-3,2e-2)
axes[0].set_yticks([0.005,0.015,0.025])
axes[1].set_ylim(0.1,8)
#axes[1].set_yticks(axes[1].get_yticks()[1:-1])
axes[2].set_ylim(0,1.8)
axes[0].set_ylabel(r'$Q$ [erg$/$cm$^{3}$$/$s]')
axes[1].set_ylabel(r'$T$ [MK]')
axes[2].set_ylabel(r'$n$ [10$^9$ cm$^{-3}$]')
axes[2].set_xlabel(r'$t$ [s]')
# Spines
axes[0].spines['bottom'].set_visible(False)
axes[0].spines['top'].set_visible(False)
axes[0].spines['right'].set_visible(False)
axes[0].tick_params(axis='x',which='both',bottom=False)
axes[1].spines['top'].set_visible(False)
axes[1].spines['bottom'].set_visible(False)
axes[1].spines['right'].set_visible(False)
axes[1].tick_params(axis='x',which='both',bottom=False)
axes[2].spines['top'].set_visible(False)
axes[2].spines['right'].set_visible(False)
fig_hydro_profiles = manager_methods.save_figure('hydro-profiles')
fig_hydro_profiles.caption = r'Heating rate (top), electron temperature (middle), and density (bottom) as a function of time for the three heating scenarios for a single loop. The colors denote the heating frequency as defined in the legend. The corresponding loop has a half length of $L/2\approx40$ Mm and a mean field strength of $\bar{B}\approx30$ G.'
\end{pycode}
\py[manager_methods]|fig_hydro_profiles|

In order to make meaningful comparisons between the various heating scenarios, we constrain the total flux into the \AR{} to be $F_{\ast}=10^7$ erg cm$^{-2}$ s$^{-1}$ \citep{withbroe_mass_1977}. For a single impulsive event $i$ as described above, the energy density is $E_i=\tau Q_i/2$. Summing over all events on all loops that comprise the \AR{},
\begin{equation}
    F_{AR} = \frac{\sum_l\sum_i E_iL_l}{t_{total}}
\end{equation}
where $t_{total}=3\times10^4$ s is the total simulation time. To constrain $F_{AR}$ according to the observed total flux, we need to satisfy
\begin{equation}\label{eq:energy_constraint}
    \frac{| F_{AR}/N_{loops} - F_{\ast} |}{F_{\ast}} < \delta,
\end{equation}
where $\delta\ll1$ and $N_{loops}=5\times10^3$ is the total number of loops comprising the \AR{}. In order to satisfy \autoref{eq:energy_constraint}, we iteratively adjust the lower bound on the power-law distribution from which we choose $E_i$ (or equivalently $Q_i$) until we have met the above condition within some numerical tolerance. Additionally, for each loop, we fix the upper bound of the event power-law distribution to be $\bar{B}_l^2/8\pi$ where $\bar{B}_l$ is the mean field strength of loop $l$ as derived from the field extrapolation. This is the maximum amount of energy that the field could possibly make available to the loop. Note that this interpretation of available energy from the field is in contradiction with our use of a potential field extrapolation as a potential field is already in its lowest energy state and thus has no energy to give up. However, our goal here is only to understand how the distribution of field strengths may be related to the properties of the heating. In this way, we use the potential field as a proxy for the non-potential component of the coronal field, noting that we cannot make any qualitative conclusions regarding the amount of available energy or the stability of the field itself.

\begin{deluxetable}{lcc}
    \tablecaption{Heating models\label{tab:heating}}
    \tablehead{\colhead{Name} & \colhead{$\varepsilon$ (see \autoref{eq:heating_types})} & \colhead{Energy Constrained?}}
    \startdata
    high frequency & 0.1 & yes \\
    intermediate frequency & 1 & yes \\
    low frequency & 5 & yes \\
    cooling & 1 event per loop & no \\
    random & 1 event per loop & no
    \enddata
\end{deluxetable}

In addition to these three multi-event heating models, we also run two single-event control models. In both control models every loop in the \AR{} is heated exactly once with an event of energy $\bar{B}_l^2/8\pi$. In our first control model, the start time of every event is $t=0$ s such that all loops are allowed cool, uninterrupted and more-or-less coherently, for $t_{total}=10^4$ s. In the second control model, the start time of the event on each loop is chosen from a uniform distribution over the interval $(0, 3\times10^4)$ s, ensuring that the heating is out of phase across all loops and thus maximally decoherent. In these two models, the energy has not been constrained according to the method described above. From here on, we will refer to these two models as the ``cooling'' and ``random'' models, respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Forward Modeling %%%%%%%%%%%%%%%%%%%%%%
\subsection{Forward Modeling}\label{forward}

\subsubsection{Atomic Physics}\label{atomic}

\begin{pycode}[manager_methods]
import plasmapy.atomic
from astropy.table import Table
from astropy.io import ascii
from synthesizAR.atomic import EmissionModel
em = EmissionModel.restore(os.path.join(manager_methods.data_dir, 'base_emission_model.json'))
data = {'Element': [], 'Number of Ions': [], 'Number of Transitions': [],}
for i in em:
    data['Element'].append(i.atomic_symbol)
    data['Number of Ions'].append(1)
    data['Number of Transitions'].append(i.transitions.wavelength.shape[0] if hasattr(i.transitions, 'wavelength') else 0)
df = pd.DataFrame(data=data).groupby('Element').sum().reset_index()
z = df['Element'].map(plasmapy.atomic.atomic_number)
df = df.assign(z = z).sort_values(by='z', axis=0).drop(columns='z')
caption = r"Elements included in the calculation of \autoref{eq:intensity}. Ions and transitions are those included in the CHIANTI atomic database.\label{tab:elements}"
\end{pycode}
\py[manager_methods]|ascii.write(Table.from_pandas(df), format='aastex', caption=caption)|

To calculate the forward modeled intensities, we account for the contributions of all transitions of all ions for a selected number of elements (see \autoref{tab:elements}). For an optically thin, high-temperature ($\sim10^6$ K), low-density ($\sim10^9$ cm$^{-3}$) plasma, the radiated power per unit volume, or \textit{emissivity}, of a transition $\lambda_{ij}$ of an electron in ion $k$ of element $X$ is given by,

\begin{equation}
    \label{eq:ppuv}
    P(\lambda_{ij}) = n_j(X_k)A_{ji}\Delta E_{ji},\quad[\text{erg cm}^{-3}\text{ s}^{-1}]
\end{equation}

where $n_j$ is the number density of ions $X_k$ in excited state $j$, $A_{ji}$ is the Einstein coefficient, and $\Delta E_{ji}=hc/\lambda_{ij}$ is the energy of the emitted photon  \citep[see][]{mason_spectroscopic_1994,bradshaw_collisional_2013}. \autoref{eq:ppuv} can be rewritten in the more useful form,

\begin{eqnarray*}
    P(\lambda_{ij}) &=& \frac{n_j(X_k)}{n(X_k)}\frac{n(X_k)}{n(X)}\frac{n(X)}{n(H)}\frac{n(H)}{n_e}n_eA_{ji}\Delta E_{ji}, \\
    &=& N_j(X,k) f_{X,k} \mathrm{Ab}(X) 0.83 n_e A_{ji} \Delta E_{ji}, \\
    &=& 0.83 \mathrm{Ab}(X) f_{X,k} N_j(X,k) A_{ji} \Delta E_{ji} n_e,
\end{eqnarray*}

where, $N_j$ is the fractional energy level population of level $j$, $f_{X,k}$ is the fractional population of ion $k$, $\mathrm{Ab}(X)$ is the abundance of element $X$ relative to hydrogen, and the ratio of hydrogen and electron number densities is $\approx0.83$. Note that $N_j A_{ji} \Delta E_{ji}$ is also sometimes referred to as the emissivity.

To compute \autoref{eq:ppuv}, we use the CHIANTI atomic database \citep{dere_chianti_1997,young_chianti_2016}. We use the abundances of \citet{feldman_potential_1992} as provided by CHIANTI. $A_{ji}$ and $E_{ji}$ for each transition can be looked up in the database. $N_j$ is a function of temperature, density, and energy level and is computed by equating the relevant excitation and de-excitation mechanisms. We selected elements from CHIANTI based on their contribution to the AIA passbands.

CHIANTI also provides $f_{X,k}$ as a function of temperature though this calculation assumes \textit{ionization equilibrium}, i.e. the ionization and recombination are always in balance. In the rarefied solar corona, where the plasma is likely heated impulsively, it is not gauranteed that the ionization timescale is less than the heating timescale, meaning that the ionization state is not necessarily representative of the electron temperature \citep{bradshaw_explosive_2006,reale_nonequilibrium_2008,bradshaw_numerical_2009}. In order to account for this possible non-equilibrium, we compute $f_{X,k}$ by solving the time-dependent level population equations for each ion in each element. The details of the calculation of non-equilibrium charge states are given in \autoref{nei}.

\subsubsection{Instrument Effects}\label{instrument}

To compute the observed \textit{intensity} along the line of sight, we need to know how much of the emission the instrument would actually detect. In this case, we want to model intensities from AIA. Thus, we convolve \autoref{eq:ppuv} with the instrument response,
\begin{equation}\label{eq:intensity}
    I_c = \frac{1}{4\pi}\sum_{\{ij\}}\int_{\text{LOS}}\mathrm{d}hP(\lambda_{ij})R_c(\lambda_{ij})
\end{equation}
where $I_c$ is the intensity for a given pixel in channel $c$, $R_c$ is the wavelength response function of the instrument for channel $c$, $\{ij\}$ is the set of all atomic transitions listed in \autoref{tab:elements}, and the integration is along the line-of-sight (LOS). Further details regarding the AIA wavelength response functions, $R_c$, can be found in \citet{boerner_initial_2012}.

\autoref{fig:aia_response} shows the effective temperature response functions for the six EUV channels on AIA compared against those calculated from \texttt{aia\_get\_response.pro} in SolarSoft \citep{freeland_data_1998}. Even though we include a limited number of transitions from the CHIANTI database, we recover nearly all of the response from each channel. The high-temperature contribution in the SolarSoft functions are due to continuum emission which we do not include in our model. In all cases, the continuum contribution is several orders of magnitude below peak of the channel response.

Note that when computing the intensity in each channel of AIA, we do not rely on the temperature response functions in SolarSoft. This is because the response functions returned by \texttt{aia\_get\_response.pro} assume 1) ionization equilibrium and 2) constant pressure. As discussed in \autoref{atomic}, the assumption of ionization equilibrium is likely to be violated in the impulsive heating cases considered here. Thus, we must recompute the contributions of each ion, using the result of \autoref{eq:nei_mat} in place of the equilibrium ionization fractions. Furthermore, during the evolution of a loop, the pressure is not constant for any of our heating scenarios as evidenced by \autoref{fig:hydro-phase-space}. The black line of constant pressure $p=10^{15}$ K cm$^{-3}$ shows the pressure at which the SolarSoft AIA response functions are evaluated. By recomputing and interpolating the emissivity, we ensure that we are evaluating all quantities in \autoref{eq:ppuv} at the correct temperature and density. \authorcomment3{Cut or move this paragraph to an appendix?}

\begin{pycode}[manager_methods]
fig = plt.figure()
ax = fig.gca()
min_T = 1e300*u.K
max_T = 0*u.K
for i,h in enumerate(heating):
    loop.parameters_savefile = os.path.join(manager_methods.data_dir, f'{h}', 'loop_parameters.h5')
    ax.plot(loop.electron_temperature[:,0], loop.density[:,0], color=colors[i], alpha=0.75,
            label=h.split('_')[0].capitalize())
    min_T = min(min_T, loop.electron_temperature.min())
    max_T = max(max_T, loop.electron_temperature.max())
p = 1e15*u.K/(u.cm**3)
T = np.linspace(min_T,max_T,1000)
ax.plot(T, p/T, color='k')
ax.set_xscale('log')
ax.set_yscale('log')
ax.set_ylabel(r'$n$ [cm$^{-3}$]')
ax.set_xlabel(r'$T$ [K]')
ax.legend(ncol=3,loc="lower left", bbox_to_anchor=(0.,1.02),frameon=False,)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
fig_hydro_phase_space = manager_methods.save_figure('hydro-phase-space')
fig_hydro_phase_space.caption = r'$n-T$ phase-space orbits for a single loop for the three heating scenarios as defined by the legend. The black line indicates a constant pressure of $10^{15}$ K cm$^{-3}$. \authorcomment3{Possibly move this to an appendix}'
\end{pycode}
\py[manager_methods]|fig_hydro_phase_space|

\begin{figure*}
    \plotone{figures/aia_response.pdf}
    \caption{SolarSoft temperature response functions (solid black) and effective temperature response functions for the elements in \autoref{tab:elements} (dashed black) for all six EUV AIA channels. The colored, dashed curves, as indicated in the legend, denote the contributions of the individual elements to the total response. For this calculation, we have assumed equilibrium ionization. \authorcomment3{Possibly move this to an appendix}}
    \label{fig:aia_response}
\end{figure*}

Once we have computed the emissivity according to \autoref{eq:ppuv} for all of the transitions in \autoref{tab:elements} and for all the loops in our \AR{}, we compute the LOS integral in \autoref{eq:intensity} by first converting all of the loop coordinates to a Helioprojective coordinate frame defined by the position of the SDO spacecraft. We then compute a weighted two-dimensional histogram of these transformed coordinates, using the emissivity values at each coordinate as the weights. We construct the histogram such that the bin widths are consistent with the spatial resolution of the instrument, i.e. in the case of AIA, a single bin, representing a single pixel, has a width of 0.6 arcseconds. Finally, we simulate the point spread function of the instrument by applying a gaussian filter to the resulting histogram. We do this for each timestep, as defined by the cadence of the instrument, and for each channel. For each heating scenario, this gives us approximately $1.8\times10^4$ separate images.
