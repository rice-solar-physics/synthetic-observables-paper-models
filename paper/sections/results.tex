%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   Results                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}\label{results}

\begin{pycode}[manager_results]
manager_results = texfigure.Manager(
    pytex,
    './',
    number=2,
    python_dir='python',
    fig_dir='figures',
    data_dir='data'
)
from formatting import qualitative_palette, heating_palette
\end{pycode}

We forward-model time-dependent AIA intensities using the method outlined in \autoref{forward} for the heating scenarios discussed in \autoref{heating}. We discuss the synthetic intensities in \autoref{intensities}. We then compute the emission measure slopes (\autoref{em_slopes}) and timelags (\autoref{timelags}) from our synthetic data. In \citetalias{barnes_understanding_2018-1}, we use these simulated observables to train a machine learning classification model to understand with which heating scenario the real data are most consistent..

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Intensities %%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Intensities}\label{intensities}

We compute the intensities for the 94, 131, 171, 193, 211, and 335 \AA{} channels of SDO/AIA using the procedure described in \autoref{forward}. We compute the intensity in each pixel of the model \AR{} over a total simulation period of $3\times10^4\,\mathrm{s}\,\approx8.3$ hours with the exception of the cooling case which is only run for $10^4$ s. We complete this procedure for each of the five heating scenarios described in \autoref{heating}.

\begin{pycode}[manager_results]
fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1.0, height_ratio=0.5, 
                                           figure_width_context='textwidth'))
plt.subplots_adjust(hspace=0.03,wspace=0.03)
t = 1500
path_format = os.path.join(manager_results.data_dir, '{}', 'map_t{:06d}_{}.fits')
for i,f in enumerate(heating):
    for j,c in enumerate(channels):
        m = Map(path_format.format(f,t,c))
        m = m.submap(SkyCoord(Tx=-390*u.arcsec,Ty=-325*u.arcsec,frame=m.coordinate_frame),
                     SkyCoord(Tx=-215*u.arcsec,Ty=-150*u.arcsec,frame=m.coordinate_frame))
        ax = fig.add_subplot(3,6,6*i+j+1,projection=m)
        norm = ImageNormalize(
            vmin=0,vmax=Map(path_format.format('low_frequency',t,c)).data.max(),
            stretch=SqrtStretch())
        m.plot(axes=ax,title=False,annotate=False,norm=norm)
        ax.grid(alpha=0)
        lon,lat = ax.coords
        lon.set_ticks(color='w',number=2)
        lat.set_ticks(color='w',number=2)
        lon.frame.set_linewidth(0)
        lat.frame.set_linewidth(0)
        if i==len(heating)-1 and j==1:
            lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
            lon.set_axislabel(r'Helioprojective Longitude [arcsec]',
                                fontsize=plt.rcParams['axes.labelsize'])
        else:
            lon.set_ticklabel_visible(False)
        if i==len(heating)-2 and j==0:
            lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'], rotation='vertical')
            lat.set_axislabel(r'Helioprojective Latitude [arcsec]',
                                fontsize=plt.rcParams['axes.labelsize'])
        else:
            lat.set_ticklabel_visible(False)
        if i==0:
            ax.set_title(f'{c} $\mathrm{{\AA}}$')
        if j == 0:
            xtext,ytext = m.world_to_pixel(
                SkyCoord(-375*u.arcsec, -175*u.arcsec, frame=m.coordinate_frame))
            ax.text(xtext.value,ytext.value,f'{f.split("_")[0].capitalize()}',
                    color='w',fontsize=plt.rcParams['xtick.labelsize'])
fig_intensity_maps = manager_results.save_figure('intensity-map',)
fig_intensity_maps.caption = r'Snapshots of intensity across the whole \AR{} at $t=15\times10^3$ s. The rows correspond to the three different heating frequencies and the columns are the six EUV channels of AIA. In each column, the colarbar is on a square root scale and is normalized between zero and the maximum intensity in the low-frequency case. The color tables are the standard AIA color tables as implemented in SunPy \citep{sunpy_community_sunpypython_2015}.'
fig_intensity_maps.figure_env_name = 'figure*'
fig_intensity_maps.figure_width = r'\textwidth'
fig_intensity_maps.placement = ''
fig_intensity_maps.fig_str = fig_str
\end{pycode}
\py[manager_results]|fig_intensity_maps|

\autoref{fig:intensity-map} shows a snapshot of the intensity map at $t=15\times10^3$ s for each channel and for the high-, intermediate-, and low-frequency nanoflare heating cases. The rows correspond to the different heating scenarios while the columns show the six channels. In each column, the intensities are normalized to the maximum intensity in the low frequency case and are on a square root scale. In general, we find that in the high frequency intensity maps, individual loops are difficult to distinguish while in the low frequency case individual loops appear bright relative to the surrounding emission. In high frequency heating, loops tend to be kept within a narrow temperature and density range because the loop is reheated often enough such that it is not allowed to cool and drain much before being reenergized. In contrast, an infrequently heated loop is allowed to fully cool and drain before the next heating event and samples a wide range of temperatures and densities as illustrated in \autoref{fig:hydro-profiles}. Thus, a snapshot of an \AR{} with many loops is likely to see a narrow range of temperatures and densities in the case of high frequency heating, but a very wide range in the case of low frequency heating. Additionally, because there are fewer low frequency events and energy is conserved across the three cases, infrequently heated loops will have higher peak densities and as a result higher peak intensities (see \autoref{eq:ppuv} and \ref{eq:intensity}). Thus, at any given time, we are likely to see a few loops with enhanced intensity in an \AR{} heated by low-frequency nanoflares, but a more uniform intensity distribution with few bright loops in an \AR{} heated by high-frequency nanoflares.

Looking at the first two columns of \autoref{fig:intensity-map}, we see that the intensity in the 94 and 131 \AA{} channels increases as the heating frequency decreases. Both channels are double peaked and have ``hot'' ($\sim7$ MK for 94 \AA{}, $\sim12$ MK for 131 \AA{}) and ``warm'' ($\sim1$ MK for 94 \AA{}, $\sim0.5$ MK for 131 \AA{}) components. In the case of high frequency heating, less energy is available per event such that few loops are heated to $>4$ MK and thus there is little emission in the 131 \AA{} channel as loops are not often permitted to cool to $0.5$ MK either. However, in the low (and intermediate) frequency case, we see several individual bright loops in both the 94 and 131 \AA{} channels as the heating rate is sufficient to produce ``hot'' (i.e. 8-10 MK) loops. We see only a few of these loops as the lifetime of this hot plasma is short due to the efficiency of thermal conduction in the early cooling phase. In contrast, the faint, diffuse component of the 94 \AA{} emission that is present in all three cases is due to the contribution of the ``warm'' component. 

We also find that the 171 \AA{} channel is dimmer for high frequency heating as the peak sensitivity of this channel is $<1$ MK and in the case of high frequency heating, loops are rarely allowed to cool below $1$ MK. In contrast, we note that the overall intensity in the 193, 211, and 335 \AA{} channels is relatively constant over heating frequency as compared to the three previous channels though individual loops do become more visible with decreasing heating frequency. This relative insensitivity is because the temperature response functions of these three channels all peak in between 1.5 MK and 2.5 MK. In the case of high-frequency heating, loops are being sustained near these temperatures while in the low-frequency case, loops are cooling through this temperature range. This is illustrated for a single loop in \autoref{fig:hydro-profiles}.

While there are clear differences in the AIA intensities for between all three heating frequencies, quantifying these differences is difficult due in part to the multidimensional nature of the intensity data. To better understand how observational signatures differ as a function of heating frequency,we need to find a reduced representation of our dataset that retains signatures of the underlying energy deposition. To this end, we compute two common observables: the emission measure slope (\autoref{em_slopes}) and the timelag (\autoref{timelags}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Emission Measure Slopes %%%%%%%%%%%%%%%%
\subsection{Emission Measure Slopes}\label{em_slopes}

As discussed in \autoref{introduction}, the emission measure slope is a useful quantity for understanding how frequently loops are reenergized. We derive emission measure distributions (\dem{}) from our forward-modeled intensities using the regularized inversion method of \citet{hannah_differential_2012}. This method was designed to work with the narrowband coverage provided by AIA and so is well-suited to our needs. We choose our temperature bins such that the leftmost edge is at $10^{5.5}$ K and the rightmost edge at $10^{7.5}$ K with bin widths of $\Delta\log T=0.1$. Rather than computing the \dem{} at each timestep, we compute the time-averaged intensity in each pixel of each channel and compute the \dem{} only once. We assume uncertainties of 20\% on the forward-modeled intensity data in every pixel and every channel. After computing the \dem{} in each pixel, we do a first-order polynomial fit to the log-transformed emission measure and temperature bin centers to calculate the emission measure slope, $a$.

\begin{pycode}[manager_results]
fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1.0, height_ratio=1/3,
                                           figure_width_context='textwidth'))
cax = fig.add_axes([0.13, -0.08, 0.77, 0.04])
params = {'cmap': 'viridis', 'vmin': 2, 'vmax': 5, 'title': False, 'annotate': False}
for i,h in enumerate(heating):
    m = Map(os.path.join(manager_results.data_dir, f'{h}', 'em_slope.fits'))
    m = m.submap(SkyCoord(Tx=-365*u.arcsec,Ty=-290*u.arcsec,frame=m.coordinate_frame),
                 SkyCoord(Tx=-230*u.arcsec,Ty=-165*u.arcsec,frame=m.coordinate_frame))
    ax = fig.add_subplot(1, len(heating), i+1, projection=m)
    im = m.plot(axes=ax, **params)
    ax.grid(alpha=0)
    lon,lat = ax.coords
    if i > 0:
        lon.set_ticks_visible(False)
        lon.set_ticklabel_visible(False)
        lat.set_ticks_visible(False)
        lat.set_ticklabel_visible(False)
    else:
        lat.set_ticks(number=3)
        lon.set_ticks(number=3)
        lon.set_axislabel('Helioprojective Longitude [arcsec]',
                          fontsize=plt.rcParams['axes.labelsize'])
        lat.set_axislabel('Helioprojective Latitude [arcsec]',
                          fontsize=plt.rcParams['axes.labelsize'])
        lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'])
        lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
    ax.set_title(h.split('_')[0].capitalize())
plt.subplots_adjust(hspace=0.03,wspace=0.03)
cbar = fig.colorbar(im, cax=cax, orientation='horizontal');
cbar.set_ticks([2,3,4,5])
fig_slope_maps = manager_results.save_figure('em-slope-maps',)
fig_slope_maps.caption = r'Maps of the emission measure slope, $a$, in each pixel of the \AR{} for the high- (left), intermediate- (center), and low-frequency (right) cases. The \dem{} is computed using time-averaged intensities from the 6 AIA EUV channels using the method of \citet{hannah_differential_2012}. The \dem{} in each pixel is then fit to $T^a$ over the temperature range $5.8<\log{T}<6.4$. The maps have been cropped in order to focus on the part of the \AR{} where $a$ is defined. Any pixels with $r^2<0.9$ are masked and colored white.'
fig_slope_maps.figure_env_name = 'figure*'
fig_slope_maps.figure_width = r'\textwidth'
fig_slope_maps.placement = ''
fig_slope_maps.fig_str = fig_str
\end{pycode}
\py[manager_results]|fig_slope_maps|

\autoref{fig:em-slope-maps} shows the resulting \dem{} slope, $a$, in each pixel of our forward-modeled \AR{} for the high-, intermediate-, and low-frequency cases. We fit the \dem{} over bins in the temperature range $5.8\le\log T\le6.4$ in order to avoid fitting across the peak of the \dem{} and underestimating the slope. To assess the ``goodness-of-fit'' of our first-order polynomial fit, we use $r^2$, the correlation coefficient, and mask pixels with $r^2<0.9$. Looking at the three panels in \autoref{fig:em-slope-maps}, we find that overall, $a$ tends to decrease with decreasing frequency. The low frequency map (right panel) shows many values close to 2. As discussed in \autoref{introduction}, this is expected as the low frequency case is essentially repeated single nanoflares on each strand. As the heating frequency increases, the slopes become larger, indicating a narrowing \dem{} distribution. The intermediate frequency map (center panel) shows predominantly higher slopes, with most pixels in the range $2\lesssim a \lesssim 3$. The high frequency map (left panel) shows many slopes in the range $4\lesssim a\lesssim5$, indicating an even more isothermal distribution. Note that largest slopes in the high frequency case occur towards the center of the \AR{} while the distribution is more spatially uniform in the intermediate- and low-frequency cases.

\begin{pycode}[manager_results]
fig = plt.figure(
    figsize=texfigure.figsize(pytex, scale=1.0, figure_width_context='columnwidth'))
ax = fig.gca()
bins = np.arange(1, 6, 0.05)
bin_centers = (bins[:-1] + bins[1:])/2
params = {'bins': bins, 'histtype': 'step','density': False, 
          'lw': plt.rcParams['lines.linewidth']}
peaks = {}
for i,h in enumerate(heating):
    d = Map(os.path.join(manager_results.data_dir, f'{h}', 'em_slope.fits')).data.flatten()
    d = d[~np.isnan(d)]
    hist, b, _ = ax.hist(d, **params, color=heating_palette()[i],
                         label=h.split('_')[0].capitalize())
    ax.axvline(x=d.mean(), ls='--', color=heating_palette()[i])
    peaks[h] = f'{bin_centers[np.argmax(hist)]:.1f}'
ax.set_xlim(1.5, 5.5);
ax.set_xticks([2, 3, 4, 5])
ax.legend(frameon=False, loc=1)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.set_yticks(ax.get_yticks()[1:-1])
ax.spines['left'].set_bounds(ax.get_yticks()[0],ax.get_yticks()[-1])
ax.spines['bottom'].set_bounds(ax.get_xticks()[0],ax.get_xticks()[-1])
ax.set_xlabel(r'$a$')
ax.set_ylabel(r'Number of Pixels')
fig_slope_histograms = manager_results.save_figure('em-slope-histograms')
fig_slope_histograms.caption = r'Distribution of \dem{} slopes, $a$, for every pixel in the simulated \AR{} for the high-, intermediate-, and low-frequency heating scenarios as shown in \autoref{fig:em-slope-maps}. The values of $a$ are binned between 1 and 6 with bin widths of 0.05. The dotted lines denote the mean of each distribution.'
fig_slope_histograms.figure_width = r'\columnwidth'
fig_slope_histograms.placement = ''
fig_slope_histograms.fig_str = fig_str
\end{pycode}
\py[manager_results]|fig_slope_histograms|

\autoref{fig:em-slope-histograms} shows histograms of the \dem{} slopes for the high-, intermediate-, and low-frequency cases. We find that the low-frequency distribution peaks at $a\approx\py[manager_results]|peaks['low_frequency']|$, with the intermediate and high frequency cases peaking at successively higher values, approximately $\py[manager_results]|peaks['intermediate_frequency']|$ and $\py[manager_results]|peaks['high_frequency']|$, respectively. While the low- and intermediate-frequency distributions are more narrowly distributed around their peak values, the high-frequency distribution has a positive skew towards higher values of $a$. This is due to the ``saturation'' of the slope at low frequencies since we expect $2<a<2.5$ for single nanoflares (see \autoref{introduction}). When the loops are reheated often (high frequency), the value of the slope becomes unsaturated and the distribution of $a$ becomes subject to differences in loop length and infrequent cooling due the dependence of each waiting time on the power-law heating rate (see \autoref{heating}). Thus we find that, even when accounting for the LOS integration, atomic physics, and uncertainties due to the \dem{} inversion, signatures of the heating frequency still persist in the emission measure slope. These results are consistent with \citet{cargill_active_2014} who computed $\mathrm{EM}(T)=n^2L$ for a single loop for a range of heating frequencies and found $a$ converged to $\approx2$ for low frequency nanoflares and increased slowly towards 6 with increasing heating frequency. 

While this quantity retains information about the frequency of energy deposition, drawing conclusions about the heating based solely on the observed \dem{} slope, particularly for a small number of pixels, may be misleading given the spread in the distribution of $a$ shown here. In \citetalias{barnes_understanding_2018-1}, we compare our modeled \dem{} slopes to slopes derived from real AIA observations of NOAA 1158.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Timelags %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Timelags}\label{timelags}

In addition to the emission measure analysis discussed in \autoref{em_slopes}, we apply the timelag method of \citet{viall_evidence_2012} to our simulated intensities for all of the heating scenarios discussed in \autoref{heating}. For each pixel in the active region, we compute the cross-correlation for every possible channel pair (15 in total) and find the temporal offset which maximizes the correlation. This offset, or \textit{timelag}, given by \autoref{eq:timelag}, indicates how much the first light curve must be shifted in time compared to the second in order to maximize the cross-correlation between the two light curves. We consider all possible offsets over the interval $\pm6$ hours. By convention, we order the channel pairs such that the hot channel is listed first, meaning that a positive timelag corresponds to variability in the hotter channel followed by variability in the cooler channel. In other words, \textit{a positive timelag indicates cooling plasma.} The details of the cross-correlation and timelag calculation are given in \autoref{timelag_details}.

%%
\subsubsection{Maps}\label{timelag_maps}

\begin{pycode}[manager_results]
fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1.0, height_ratio=3/5,
                                           figure_width_context='textwidth'))
cax = fig.add_axes([0.125, -0.01, 0.775, 0.02])
heating += ['random', 'cooling']
file_format = os.path.join(manager_results.data_dir, '{}', '{}_{}_{}.fits')
correlation_threshold = 0.1
plot_params = {'title': False, 'annotate': False, 'vmin': -(5e3*u.s).to(u.s).value,
               'vmax': (5e3*u.s).to(u.s).value, 'cmap': 'RdYlBu_r',}
selected_channel_pairs = [(94,335), (211,131), (193,171)]
for j,h in enumerate(heating):
    for i,cp in enumerate(selected_channel_pairs):
        m = Map(file_format.format(h, 'timelag', *cp))
        mc = Map(file_format.format(h, 'correlation', *cp))
        m = Map(m.data, m.meta, mask=np.where(mc.data<=correlation_threshold, True, False))
        m = m.submap(SkyCoord(Tx=-440*u.arcsec,Ty=-380*u.arcsec,frame=m.coordinate_frame),
                     SkyCoord(Tx=-185*u.arcsec,Ty=-125*u.arcsec,frame=m.coordinate_frame))
        ax = fig.add_subplot(len(selected_channel_pairs), len(heating), j+len(heating)*i+1,
                             projection=m)
        im = m.plot(axes=ax, **plot_params)
        ax.grid(alpha=0)
        lon = ax.coords[0]
        lat = ax.coords[1]
        lon.set_ticks(number=3)
        lat.set_ticks(number=3,) 
        if j == 0 and i == 1:
            lat.set_axislabel(r'Helioprojective Latitude [arcsec]', fontsize=plt.rcParams['axes.labelsize'])
            lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'], rotation='vertical')
        else:
            lat.set_ticklabel_visible(False)
        if j == 1 and i == 2:
            lon.set_axislabel(r'Helioprojective Longitude [arcsec]', fontsize=plt.rcParams['axes.labelsize'])
            lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
        else:
            lon.set_ticklabel_visible(False)
        if i == 0:
            ax.set_title(h.split('_')[0].capitalize())
        if j == 0:
            xtext,ytext = m.world_to_pixel(SkyCoord(-425*u.arcsec, -165*u.arcsec, frame=m.coordinate_frame))
            ax.text(xtext.value, ytext.value, '{}-{} $\mathrm{{\AA}}$'.format(*cp),
                    color='k', fontsize=plt.rcParams['xtick.labelsize'])
plt.subplots_adjust(wspace=0.03,hspace=0.03)
cbar = fig.colorbar(im, cax=cax,orientation='horizontal')
fig_timelag_maps = manager_results.save_figure('timelag-maps',)
fig_timelag_maps.caption = r'Timelag maps for three different channel pairs for all five of the heating models described in \autoref{heating}. The value of each pixel indicates the temporal offset which maximizes the cross-correlation (see \autoref{eq:timelag}). The columns indicate the different channel pairs and the rows indicate the three heating scenarios plus our two control cases. The colorbar ranges from -5000 s to +5000 s.'
fig_timelag_maps.figure_env_name = 'figure*'
fig_timelag_maps.figure_width = r'\textwidth'
fig_timelag_maps.placement = ''
fig_timelag_maps.fig_str = fig_str
\end{pycode}
\py[manager_results]|fig_timelag_maps|

\autoref{fig:timelag-maps} shows $\tau_{AB}$ (see \autoref{eq:timelag}) in each pixel of our simulated \AR{} for all heating scenarios listed in \autoref{tab:heating} and three selected channel pairs: 94-335 \AA{}, 211-131 \AA{}, and 193-1171 \AA{}. Blues correspond to negative timelags, reds correspond to positive timelags and pale yellow indicates zero timelag. The range of the colorbar is $\pm5000$ s. Note that the frequency decreases as we move left to right across each row. If the correlation in a given pixel is too low ($\max{\mathcal{C}_{AB}}<0.1$), we mask that pixel and color it white. 

We look first at the 94-335 \AA{} channel pair. For every heating scenario, a similar pattern emerges: near zero timelags in the inner core of the \AR{}, short positive timelags ($\approx2000$ s) in the outer core, and negative timelags on the outer edge of the \AR{}. Note that a positive timelag in this channel means that variability in the 335 channel follows variability in the 94 channel, implying that plasma is cooling through $\approx8$ MK down to $\approx2$ MK (see \autoref{fig:aia-response}). The increasing magnitude of the positive timelags as we move away from the center of the \AR{} is due to the distribution of loop lengths. Shorter loops are concentrated in the center of the \AR{} (see \autoref{fig:magnetogram}) and because $\tau_{cool}\propto L$ \citep[see Appendix of][]{cargill_active_2014}, longer loops take more time to cool through the same temperature interval. The negative timelags far from the center of the \AR{} are rooted in areas of weaker magnetic field and are not heated into the temperature range of the ``hot'' part of the 94 \AA{} channel. Thus, the cooling from 335 \AA{} to the cooler part of 94 \AA{} dominates the cross-correlation curve, producing a negative timelag. These negative timelags occur closer to the core as the heating frequency increases (from right to left in \autoref{fig:timelag-maps}) because the more often a loop is heated, the weaker the individual events will be. 

\authorcomment1{Observations of negative 131 timelags consistent with results of \citet{cadavid_heating_2014}}

In the 211-131 \AA{} channel pair, we see that as the frequency decreases, long positive timelags tend to dominate at the outer edge of the \AR{}, with the length of the timelag decreasing as we move toward the center of the \AR{}. As discussed above, this is due to the dependence of the loop cooling time on the loop length. This pattern is most apparent in the low frequency, random, and cooling cases (the last three columns of \autoref{fig:timelag-maps}) while the high and intermediate frequency cases show a mix of positive and negative timelags across the whole \AR{} with few areas of spatially coherent positive timelags. At high and intermediate frequencies, the majority of the loops are reheated often enough that they are not allowed fully cool through the 131 \AA{}, meaning that the cooling behavior from 211 \AA{} to 131 \AA{} does not dominate the cross-correlation curve. Note that the positive timelags in the 211-131 \AA{} channel pair are significantly longer than those in the 94-335 \AA{} despite the temperature separation in first pair being significantly larger than the second pair, $\Delta T_{94-335}>\Delta T_{211-131}$. In the temperature range $2.5<T<7.3$ MK, the dominant loop cooling mechanism is thermal conduction while radiative cooling dominates in the range $0.6<T<2.5$ MK. Because thermal conduction is far more efficient, a loop spends less time in the $[T_{335},T_{94}]$ temperature range than in $[T_{131},T_{211}]$ despite the former being a wider interval.

Additionally, we note the presence of negative 211-131 \AA{} timelags in the center of the \AR{} in the low, intermediate, and high frequency cases. These negative timelags correspond to plasma cooling from the hot part of the 131 \AA{} channel through the 211 \AA{} channel and thus indicate  $\ge10$ MK plasma. Notably, these negative timelags are independent of heating frequency. Because these inner core loops are rooted in areas of strong field, enough energy is made available by the field (see discussion in \autoref{heating}) to heat them well into the hot part of the 131 \AA{} passband. Furthermore, because these are relatively short loops, the density increases rapidly enough for this hot plasma to be visible before it is washed out by thermal conduction. Though we have not shown them here, similar negative timelag signatures are present in nearly all of the other 131 \AA{} channel pairs as well. \authorcomment1{Why not in the random and cooling cases?}.

Lastly, we look at results from the 193-171 \AA{} channel pair as shown in the last row of \autoref{fig:timelag-maps}. Note that in all five heating scenarios, zero timelag dominates the inner core of the \AR{}. This underscores the point that zero timelags do not correspond to steady heating \citep[see][]{viall_transition_2015,viall_signatures_2016}. As in the other two channel pairs, we find positive timelags which decrease in duration as we move towards the center of the \AR{} and this pattern becomes more apparent as the frequency decreases. Furthermore, we find very few negative timelags other than in the high frequency case where the cross-correlation is less likely to have a ``preferred'' timelag. This is because, unlike the 94 \AA{} and 131 \AA{} channels, the 193 \AA{} and 171 \AA{} channels are strongly peaked about a single temperature. Thus, persistent, spatially-coherent negative timelags could only be caused by a heating signature from 0.9 MK up to 1.5 MK. 

\begin{pycode}[manager_results]
fig = plt.figure(figsize=texfigure.figsize(pytex, scale=1.0, height_ratio=3/5,
                                           figure_width_context='textwidth'))
cax = fig.add_axes([0.125, -0.01, 0.775, 0.02])
plot_params = {'title': False, 'annotate': False, 'vmin': 0, 'vmax': 1, 'cmap': 'magma',}
for j,h in enumerate(heating):
    for i,cp in enumerate(selected_channel_pairs):
        m = Map(file_format.format(h, 'correlation', *cp))
        m = m.submap(SkyCoord(Tx=-440*u.arcsec,Ty=-380*u.arcsec,frame=m.coordinate_frame),
                     SkyCoord(Tx=-185*u.arcsec,Ty=-125*u.arcsec,frame=m.coordinate_frame))
        ax = fig.add_subplot(len(selected_channel_pairs), len(heating), j+len(heating)*i+1,
                             projection=m)
        im = m.plot(axes=ax, **plot_params)
        ax.grid(alpha=0)
        lon = ax.coords[0]
        lat = ax.coords[1]
        lon.set_ticks(number=3,color='w')
        lat.set_ticks(number=3,color='w')
        lon.frame.set_linewidth(0)
        lat.frame.set_linewidth(0)
        if j == 0 and i == 1:
            lat.set_axislabel(r'Helioprojective Latitude [arcsec]', fontsize=plt.rcParams['axes.labelsize'])
            lat.set_ticklabel(fontsize=plt.rcParams['ytick.labelsize'], rotation='vertical')
        else:
            lat.set_ticklabel_visible(False)
        if j == 1 and i == 2:
            lon.set_axislabel(r'Helioprojective Longitude [arcsec]', fontsize=plt.rcParams['axes.labelsize'])
            lon.set_ticklabel(fontsize=plt.rcParams['xtick.labelsize'])
        else:
            lon.set_ticklabel_visible(False)
        if i == 0:
            ax.set_title(h.split('_')[0].capitalize())
        if j == 0:
            xtext,ytext = m.world_to_pixel(SkyCoord(-425*u.arcsec, -165*u.arcsec, frame=m.coordinate_frame))
            ax.text(xtext.value, ytext.value, '{}-{} $\mathrm{{\AA}}$'.format(*cp),
                    color='w', fontsize=plt.rcParams['xtick.labelsize'])
plt.subplots_adjust(wspace=0.03, hspace=0.03)
cbar = fig.colorbar(im, cax=cax,orientation='horizontal')
fig_correlation_maps = manager_results.save_figure('correlation-maps',)
fig_correlation_maps.caption = r'Same as \autoref{fig:timelag-maps} except here we show the maximum value of $\mathcal{C}_{AB}$ in each pixel.'
fig_correlation_maps.figure_env_name = 'figure*'
fig_correlation_maps.figure_width = r'\textwidth'
fig_correlation_maps.placement = ''
fig_correlation_maps.fig_str = fig_str
\end{pycode}
\py[manager_results]|fig_correlation_maps|

\autoref{fig:correlation-maps} shows the peak cross-correlation value, $\max\mathcal{C}_{AB}$, for each selected channel pair. Looking first at all three channel pairs, we see that, on average, the cross-correlation increases as the heating frequency decreases. Additionally, we find that the highest cross-correlations tend to be in the center of the \AR{} while the lowest tend to be on the outer edge. Furthermore, other than the ``cooling'' scenario, we find that there are large variations from one loop to the next for all heating frequencies such that the spatial coherence of these peak cross-correlation values is low. In \citetalias{barnes_understanding_2018-1}, we will use the peak cross-correlation value, in addition to the timelag, to classify the heating frequency in each observed pixel. \authorcomment2{Do we need some more discussion here?}

%%
\subsubsection{Histograms}\label{timelag_histograms}

\begin{pycode}[manager_results]
fig,axes = plt.subplots(
    len(channel_pairs), len(heating),
    figsize=texfigure.figsize(pytex, scale=1.0, height_ratio=1.0,
                              figure_width_context='textwidth'))
bins = np.arange((-10e3*u.s).value, (10e3*u.s).value, (60*u.s).value)
plot_params = {'histtype':'step', 'bins':bins,'log':True,
               'lw': 1}
from formatting import heating_palette
colors = heating_palette(n_colors=len(heating))
for i,cp in enumerate(channel_pairs):
    for j,h in enumerate(heating):
        ax = axes[i,j]
        # Select Map and Mask
        m = Map(file_format.format(h,'timelag',*cp))
        mc = Map(file_format.format(h,'correlation',*cp))
        m = Map(m.data, m.meta, mask=np.where(mc.data<=correlation_threshold, True, False))
        hist, bins, _ = ax.hist(m.data[~m.mask].flatten(), **plot_params, color=colors[j])
        ax.axvline(x=0, ls=':', alpha=0.75, color='k', lw=1)
        # Channel and Heating Labels
        if j==0 and (i+1)%2 != 0:
            ax.set_ylabel('{}-{}'.format(*cp))
        if j==len(heating)-1 and (i+1)%2 == 0:
            ax.set_ylabel('{}-{}'.format(*cp))
            ax.yaxis.set_label_position('right')
        if i==0:
            ax.set_title(h.split('_')[0].capitalize())
        # Limits
        ax.set_ylim(2,1e5)
        ax.set_xlim(1.1*bins[0], 1.1*bins[-1])
        # Spines and limits
        if j > 0:
            ax.spines['left'].set_visible(False)
            ax.tick_params(axis='y',which='both',length=0,labelleft=False)
        else:
            if i < len(channel_pairs) - 1:
                ax.tick_params(axis='y',which='both',labelleft=False)
        if j < len(heating)-1:
            ax.spines['right'].set_visible(False)
        if i > 0:
            ax.spines['top'].set_visible(False)
        if i < len(channel_pairs)-1:
            ax.spines['bottom'].set_visible(False)
            ax.tick_params(axis='x',which='both',length=0,labelbottom=False)
        else:
            if j > 0:
                ax.tick_params(axis='x',which='both',labelbottom=False)
axes[len(channel_pairs)-1,0].set_xlabel(r'$\tau_{AB}$ [s]')
plt.subplots_adjust(hspace=0,wspace=0)
fig_timelag_histograms = manager_results.save_figure('timelag-histograms',)
fig_timelag_histograms.caption = r'Histograms of timelag values across the whole \AR{}. The rows indicate the different channel pairs and the columns indicate the different heating models. Colors are used to denote the various heating models. The bin range is $\pm10^4$ s and the bin width is 60 s. As with the timelag maps, we do not include timelags corresponding to $\mathcal{C}_{AB}<0.1$.'
fig_timelag_histograms.figure_env_name = 'figure*'
fig_timelag_histograms.figure_width = r'\textwidth'
fig_timelag_histograms.placement = ''
fig_timelag_histograms.fig_str = fig_str
\end{pycode}
\py[manager_results]|fig_timelag_histograms|

\autoref{fig:timelag-histograms} shows histograms of timelags for every possible channel pair and all five heating scenarios. Each histogram is colored according the corresponding heating function. The timelags are binned between -10000 s and +10000 s in 60 s bins. The columns are arranged such that heating frequency decreases from left to right. We show each channel pair for all heating models to demonstrate how the distribution of timelags evolves as the heating frequency varies.

Note that as the frequency decreases (from left to right), the number of negative timelags decreases. In the ``cooling'' case, there are very few negative timelags except for channel pairs which include one or both of the double-peaked channels, 94 \AA{} and 131 \AA{}. In the case of those channel pairs, we expect to find negative timelags, even in our single-nanoflare cooling case, because our convention of ordering the ``hot'' channel first has been violated such that cooling plasma can lead to negative timelags. For the remaining channel pairs, negative timelags are associated with the loop heating and cooling cycle being interrupted by repeated events on a given strand. In the ``cooling'' case, these channel pairs have none or very few negative timelags as we expect. 

Additionally, in every channel pair, the distribution of positive timelags narrows as the heating frequency decreases. For a single loop, the maximum allowed timelag for given channel pair $AB$ is just the amount of time the loop takes to cool from $T_A$ to $T_B$ by thermal conduction and radiation. Given that all loops were heated only once at $t=0$ s, we may regard our ``cooling'' case as our baseline timelag distribution. Two effects are likely to alter this baseline timelag distribution: multiple out-of-phase structures along a given LOS (the ``random'' heating scenario) and multiple reheatings on a given loop before the end of the loop cooling cycle. \authorcomment2{Say something more here about the high-frequency distribution being flat and how steady heating is the limiting case of high-frequency heating} This is consistent with the results of \citet{viall_signatures_2016} who found that steadily-heated loops have no preferred timelag and thus result in a flat distribution of timelags. 

